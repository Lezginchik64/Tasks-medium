# -- Функции any(), all(), zip(), enumerate() --

# -- Функция all() --
# Встроенная функция all() возвращает значение True, если все элементы переданной ей последовательности (итерируемого объекта) истинны (приводятся к значению True), или False в противном случае.
# Сигнатура функции следующая: all(iterable). В качестве iterable может выступать любой итерируемый объект:
    # список;
    # кортеж;
    # строка;
    # множество;
    # словарь и т.д.

# Напомним, что в Python все следующие значения приводятся к значению False:
# константы None и False;
# нули всех числовых типов данных: 0, 0.0, 0j, Decimal(0), Fraction(0, 1);
# пустые коллекции: '', (), [], {}, set(), range(0).

print(all([1, 2, 3]))
print(all([1, 2, 3, 0, 5]))
print(all([True, 0, 1]))
print(all(('', 'red', 'green')))
print(all({0j, 3+4j}))
print()
# True
# False
# False
# False
# False

# При работе со словарями функция all() проверяет на соответствие параметрам True ключи словаря, а не их значения.
dict1 = {0: 'Zero', 1: 'One', 2: 'Two'}
dict2 = {'Zero': 0, 'One': 1, 'Two': 2}

print(all(dict1))   # False
print(all(dict2))   # True

# Обратите внимание: если переданный итерируемый объект пустой, то функция all() возвращает значение True.
print(all([]))          #  передаем пустой список
print(all(()))          #  передаем пустой кортеж
print(all(''))          #  передаем пустую строку
print(all([[], []]))    #  передаем список, содержащий пустые списки
print()
# True
# True
# True
# False




# -- Функция any() --
# Встроенная функция any() возвращает значение True, если хотя бы один элемент переданной ей последовательности (итерируемого объекта) является истинным (приводится к значению True), или False в противном случае.
# Сигнатура функции следующая: any(iterable). В качестве iterable может выступать любой итерируемый объект:
# список;
# кортеж;
# строка;
# множество;
# словарь и т.д.

print(any([False, True, False]))       #  возвращает True, так как есть хотя бы один элемент, равный True
print(any([False, False, False]))      #  возвращает False, так как нет элементов, равных True
print()
# True
# False

print(any([0, 0, 0]))
print(any([0, 1, 0]))
print(any([False, 0, 1]))
print(any(['', [], 'green']))
print(any({0j, 3+4j, 0.0}))
# False
# True
# True
# True
# True

# При работе со словарями функция any() проверяет на соответствие True ключи словаря, а не их значения.
dict1 = {0: 'Zero'}
dict2 = {'Zero': 0, 'One': 1}

print(any(dict1)) # False
print(any(dict2)) # True

# Обратите внимание: если переданный объект пуст, то функция any() возвращает значение False.
print(any([]))          #  передаем пустой список
print(any(()))          #  передаем пустой кортеж
print(any(''))          #  передаем пустую строку
print(any([[], []]))    #  передаем список, содержащий пустые списки
print()
# False
# False
# False
# False


# -- Функции all() и any() в связке с функцией map() --
# Функции all() и any() могут быть полезны в комбинации с функцией map(), которая может преобразовывать элементы последовательности (итерируемого объекта) к значению True/False в соответствии с неким условием.
# Приведенный ниже код, проверяет, все ли элементы списка numbers больше 10:
numbers = [17, 90, 78, 56, 231, 45, 5, 89, 91, 11, 19]
res = all(map(lambda x: True if x > 10 else False, numbers))

if res:
    print('Все числа больше 10')
else:
    print('Хотя бы одно число меньше или равно 10')
# Хотя бы одно число меньше или равно 10

# Так как список numbers содержит число 5, которое не больше чем 10.
# Лямбда функцию, которая преобразует элементы списка numbers в значения True/False можно упростить следующим образом:
res = all(map(lambda x: x > 10, numbers))

# Приведенный ниже код проверяет, что хотя бы один элемент списка четное число:
numbers = [17, 91, 78, 55, 231, 45, 5, 89, 99, 11, 19]
result = any(map(lambda x: x % 2 == 0, numbers))
if result:
    print('Хотя бы одно число четное')
else:
    print('Все числа нечетные')
print()
# Хотя бы одно число четное
# так как список numbers содержит четное число 78.




# -- Функция enumerate() --
# Встроенная функция enumerate() возвращает кортеж из индекса элемента и самого элемента переданной ей последовательности (итерируемого объекта).
# Сигнатура функции следующая: enumerate(iterable, start). В качестве iterable может выступать любой итерируемый объект:
    # список;
    # кортеж;
    # строка;
    # множество;
    # словарь и т.д.

# С помощью необязательного параметра start можно задать начальное значение индекса.
# По умолчанию значение параметра start = 0, то есть счет начинается с нуля.
colors = ['red', 'green', 'blue']
for pair in enumerate(colors):
    print(pair)
print()
# (0, 'red')
# (1, 'green')
# (2, 'blue')

# Если счет нужно начать с отличного от нуля числа, то нужно передать значение аргумента start.
colors = ['red', 'green', 'blue']

for pair in enumerate(colors, 100):
    print(pair)
print()
# (100, 'red')
# (101, 'green')
# (102, 'blue')

# Обратите внимание, функция enumerate() возвращает не список, а специальный объект, который называется итератором.
# Такой объект похож на список тем, что его можно перебирать циклом for, то есть итерировать.
# Итератор можно преобразовать в список с помощью функции list().
colors = ['red', 'green', 'blue']
pairs = enumerate(colors)
print(pairs)    # <enumerate object at 0x...>
print(list(pairs))  # [(0, 'red'), (1, 'green'), (2, 'blue')]
print()

# Мы также можем использовать распаковку кортежей при итерировании с помощью цикла for.
colors = ['red', 'green', 'blue']
for index, item in enumerate(colors):
    print(index, item)
print()
# 0 red
# 1 green
# 2 blue

# Пример enumerate для словаря
d = {'AMEZ': 'ПАО "Ашинский метзавод"', 'CHMF': 'ПАО "Северсталь"',
     'CHMK': 'ПАО "ЧМК"', 'GMKN': 'ПАО "ГМК "Норильский никель"',
     'MAGN': 'ПАО "ММК"', 'MTLR': 'ПАО "Мечел"',
     'NLMK': 'ПАО "НЛМК"', 'RUAL': 'МКПАО "ОК РУСАЛ"',
     'TRMK': 'ПАО "ТМК"'}

items = list(d.items())
d = {}
for index, (key, value) in enumerate(items):
    if index % 2 == 0:
        d[key] = value
print(d)
print()
# {'AMEZ': 'ПАО "Ашинский метзавод"', 'CHMK': 'ПАО "ЧМК"', 'MAGN': 'ПАО "ММК"', 'NLMK': 'ПАО "НЛМК"', 'TRMK': 'ПАО "ТМК"'}




# -- Функция zip() --
# Встроенная функция zip() объединяет отдельные элементы из каждой переданной ей последовательности (итерируемого объекта) в кортежи.
# Сигнатура функции следующая: zip(*iterables). В качестве iterable может выступать любой итерируемый объект:
    # список;
    # кортеж;
    # строка;
    # множество;
    # словарь и т.д.

numbers = [1, 2, 3]
words = ['one', 'two', 'three']
for pair in zip(numbers, words):
    print(pair)
print()
# (1, 'one')
# (2, 'two')
# (3, 'three')

# Функция zip(), как и функция enumerate() возвращает не список, а специальный объект, который называется итератором.
# Мы можем передавать функции zip() сколько угодно итерируемых объектов.
numbers = [1, 2, 3]
words = ['one', 'two', 'three']
romans = ['I', 'II', 'III']

result = zip(numbers, words, romans)
print(list(result))     # [(1, 'one', 'I'), (2, 'two', 'II'), (3, 'three', 'III')]
print()

# Мы можем передать функции zip() даже один итерируемый объект.
numbers = [1, 2, 3]
result = zip(numbers)
print(list(result))     # [(1,), (2,), (3,)]

# Если функции zip() передать итерируемые объекты, имеющие разную длину, то объект с наименьшим количеством элементов определяет итоговую длину.
numbers = [1, 2, 3, 4]
words = ['one', 'two']
romans = ['I', 'II', 'III']

result = zip(numbers, words, romans)
print(list(result))     # [(1, 'one', 'I'), (2, 'two', 'II')]
print()


# -- Частые сценарии использования функции zip() --

# Сценарий 1. Функция zip() удобна для создания словарей, когда ключи и значения находятся в разных списках.
keys = ['name', 'age', 'gender']
values = ['Timur', 28, 'male']

info = dict(zip(keys, values))
print(info)     # {'name': 'Timur', 'age': 28, 'gender': 'male'}
print()

# Сценарий 2. Функция zip() удобна для одновременного (параллельного) итерирования сразу по нескольким коллекциям.
name = ['Timur', 'Ruslan', 'Rustam']
age = [28, 21, 19]

for x, y in zip(name, age):
    print(x, y)
print()
# Timur 28
# Ruslan 21
# Rustam 19



# -- Примечания --

# Примечание 1. Итераторы – важная концепция языка Python. Нужно помнить:
# итераторы можно обойти циклом for;
# итератор можно преобразовать в список или кортеж, с помощью функций list() и tuple();
# итератор можно распаковать с помощью *.

# Примечание 2. Реализация встроенных функций all() и any() выглядит примерно так:
def all(iterable):
    for item in iterable:
        if not item:
            return False
    return True

def any(iterable):
    for item in iterable:
        if item:
            return True
    return False

# Примечание 3. Мы можем использовать одновременно функции zip() и enumerate():
list1 = ['a1', 'a2', 'a3']
list2 = ['b1', 'b2', 'b3']
for index, (i1, i2) in enumerate(zip(list1, list2)):
    print(index, i1, i2)

# 0 a1 b1
# 1 a2 b2
# 2 a3 b3