# -- Функции с переменным количеством аргументов --

# Переменное количество аргументов
# В заголовке функции my_func() указан всего один параметр args, но со звездочкой перед ним.
# Звездочка в определении функции означает, что переменная (параметр) args получит в виде кортежа все аргументы, переданные в функцию при ее вызове от текущей позиции и до конца.
def my_func(*args):
    print(type(args))
    print(args)

my_func()
my_func(1, 2, 3)
my_func('a', 'b')
print()

# При описании функции можно использовать только ОДИН параметр помеченный звездочкой, причем располагаться он должен в конце списка параметров, иначе последующим параметрам не достанется значений.
def my_func(num, *args):
    print(args)
    print(num)

my_func(17, 'Python', 2, 'C#')
print()



# -- Передача аргументов в форме списка и кортежа --
# Иногда хочется сначала сформировать набор аргументов, а потом передать их функции.
# Тут поможет оператор распаковки коллекций, который также обозначается звездочкой *.
def my_sum(*args):
    return sum(args)    # args - это кортеж

print(my_sum())
print(my_sum(1))
print(my_sum(1, 2))
print(my_sum(1, 2, 3))
print(my_sum(1, 2, 3, 4))
# Мы также можем вызывать нашу функцию my_sum() , передавая ей списки или кортежи, предварительно распаковав их.
print(my_sum(*[1, 2, 3, 4, 5]))   #  распаковка списка
print(my_sum(*(1, 2, 3)))         #  распаковка кортежа
# Более того, часть аргументов можно передавать непосредственно и даже коллекции подставлять не только по одной.
print(my_sum(1, 2, *[3, 4, 5], *(7, 8, 9), 10))
print()


# -- Получение именованных аргументов в виде словаря --
# Позиционные аргументы можно получать в виде *args, причём произвольное их количество. Такая возможность существует и для именованных аргументов.
# Только именованные аргументы получаются в виде словаря, что позволяет сохранить имена аргументов в ключах.
def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)

my_func()
my_func(a=1, b=2)
my_func(name='Timur', job='Teacher')
print()

# Параметр  **kwargs пишется в самом конце, после последнего аргумента со значением по умолчанию.
# При этом функция может содержать и *args и **kwargs параметры.
def my_func(a, b, *args, name='Gvido', age=17, **kwargs):
    print(a, b)
    print(args)
    print(name, age)
    print(kwargs)

my_func(1, 2, 3, 4, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, 3, 4, job='Teacher', language='Python')
print()


# -- Передача именованных аргументов в форме словаря --
# Как и в случае позиционных аргументов, именованные можно передавать в функцию "пачкой" в виде словаря.
# Для этого нужно перед словарём поставить две звёздочки.
def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)

info = {'name':'Timur', 'age':'28', 'job':'teacher'}
my_func(**info)
print()


def print_info(name, surname, age, city, *children, **additional_info):
    print('Имя:', name)
    print('Фамилия:', surname)
    print('Возраст:', age)
    print('Город проживания:', city)
    if len(children) > 0:
        print('Дети:', ', '.join(children))
    if len(additional_info) > 0:
        print(additional_info)

children = ['Бодхи Рансом Грин', 'Ноа Шэннон Грин', 'Джорни Ривер Грин']
additional_info = {'height':163, 'job':'actress'}

print_info('Меган', 'Фокс', 34, 'Ок-Ридж', *children, **additional_info)
print()
# При подстановке аргументов "разворачивающиеся" наборы аргументов вроде *positional и **named можно указывать вперемешку с аргументами соответствующего типа: *positional с позиционными, а **named — с именованными.
# И, конечно, же, все именованные аргументы должны идти после всех позиционных!


# -- Keyword-only аргументы --
# В Python 3 добавили возможность пометить именованные аргументы функции так, чтобы вызвать функцию можно было, только передав эти аргументы по именам.
# Такие аргументы называются keyword-only и их нельзя передать в функцию в виде позиционных.
def make_circle(x, y, radius, *, line_width=1, fill=True):
    return
make_circle(10, 20, 5)                                     # x=10, y=20, radius=5,  line_width=1, fill=True
make_circle(x=10, y=20, radius=7)                                      # x=10, y=20, radius=7,  line_width=1, fill=True
make_circle(10, 20, radius=10, line_width=2, fill=False)          # x=10, y=20, radius=10, line_width=2, fill=False
make_circle(x=10, y=20, radius=17, line_width=3)                       # x=10, y=20, radius=17, line_width=3, fill=True
# То есть аргументы x, y и radius могут быть переданы в качестве как позиционных, так и именованных аргументов.
# При этом аргументы line_width и fill могут быть переданы только как именованные аргументы.

# Мы также можем объявить функцию, у которой будут только строго именованные аргументы, для этого нужно поставить звёздочку в самом начале перечня аргументов.
def make_circle(*, x, y, radius, line_width=1, fill=True):
    return
# Теперь для вызова функции make_circle() нам нужно передать значения всех аргументов явно через их имя:
make_circle(x=10, y=20, radius=15)                              # line_width=1, fill=True
make_circle(x=10, y=20, radius=15, line_width=4, fill=False)
print()
# Такой разделитель можно использовать только один раз в определении функции.
# Его нельзя применять в функциях с неограниченным количеством позиционных аргументов *args.


# Примечание.
# Порядок параметров:
    # 1. Позиционные аргументы без значений по умолчанию.
    # 2. Позиционные аргументы со значениями по умолчанию.
    # 3. Позиционные аргументы, указанные как *args.
    # 4. Именованные аргументы.
    # 5. Именнованные со значением по умолчанию
    # 6. Именованные аргументы, указанные как *kwargs.

def my_func(a, b, c=10, *args, d, g=1, **kwargs):
    print(a, b)
    print(c)
    print(args)
    print(d)
    print(g)
    print(kwargs)

my_func(1, 2, 3, 4, 5, d=3, g=2, f=1)